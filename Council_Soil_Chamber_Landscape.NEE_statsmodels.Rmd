---
title: 'Council_Soil_Chamber_Landscape.NEE' #breaking NEE apart by plot type for stats, adapted from NEE_statsmodels.Rmd 
##time is in AK daylight time** NEE/RECO/GPP are in gC/m2/s; FCO2 and FCH4 are in gC/m2/s, flux_CO2 is in umol/m2/s; flux_CH4 is in nano mol/m2/s
output: html_document
date: "2025-03-10"
---

```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = TRUE)
```

#Load libraries 
```{r, include=FALSE}
rm(list= ls())

library(data.table)
library(ggplot2)
library(cowplot)
library(openair)
library(plotrix)
library(signal)
library(svMisc)
library(zoo)
library(stringr)
library(plyr)
library(viridis)
library(lubridate)
library(tidyverse)
library(gridExtra)
library(plotly)
library(RColorBrewer)
library(pracma)
library(dplyr)
library(openair)
library(nlme)
library(lme4)

Sys.setenv(TZ='UTC')

```

#Load filtered and merged df of soil chamber fluxes, moisture, temp (I upload multiples but only using df_NEE_RECO2 and df_NEE_RECO2_GPP for analysis below)
```{r}
# #filtered for p<0.05; units umol/m2/s or nmol/m2/s
# df_soilchambers_filtered = fread('C:/Users/kkent/Documents/Council Data/Soil Chambers_Council/council_filtered_soil_chamber_fluxes_2017to2019.csv')
# 
# #fluxes and moisture/temp df merged; FCO2 in units g/m2/s
# df_fulljoin = fread('C:/Users/kkent/Documents/Council Data/Soil Chambers_Council/council_fulljoin_soilchamber_fluxes_moisttemp_2017to2019.csv')

# *****************Use these two, above are just extra if needed for looking at*********************

#used transparent and opaque chambers to identify NEE and RECO, then merged back together 
df_NEE_RECO2 = fread('C:/Users/kkent/Documents/Council Data/Soil Chambers_Council/council_fulljoin_soilchamber_fluxes_moisttemp_2017to2019.csv')

#calculated GPP (NEE - Reco)
df_NEE_RECO2_GPP = fread('C:/Users/kkent/Documents/Council Data/Soil Chambers_Council/council_NEE_RECO2_GPP_2017to2019.csv')


```


#Re-shape df into long format 
```{r}
library(tidyr)

#Remove the NAs from inundation 
library(dplyr)
df_NEE_RECO2_GPP<- df_NEE_RECO2_GPP %>%
   filter(!is.na(inundated))


# Reshape the dataframe to long format, choose variables of interest 
df_long <- df_NEE_RECO2_GPP %>%
  select(plot_ID, plot_type, landscape_position, measurement_date, time, date, VWC, air_temp, flux_CO2, flux_CH4, FCH4, NEE, RECO, GPP, inundated, soil_temp_10_cm, soil_temp_15_cm, thawdepth) %>%
  pivot_longer(cols = c(NEE, RECO, GPP), 
               names_to = "flux_type", 
               values_to = "flux_value")


```


#Filter df by landscape position and flux type (GPP, NEE, RECO)

####Create new df for each plot type for analysis 
```{r}
#Filter & make separate datasets for each plot_ID = "EC" "MW" and "BGC", and by flux type (GPP, NEE, RECO)

#NEE
df_NEE <-df_long %>%
  filter(flux_type == "NEE")

```

#Filter for NEE 
```{r}
#make sure to use complete cases of all variables of interest 
df_NEE <- df_NEE %>%
   filter(complete.cases(flux_value, thawdepth, soil_temp_10_cm,landscape_position, inundated, VWC, air_temp))


sum(is.na(df_NEE$VWC)) 
sum(is.na(df_NEE$thawdepth)) 
sum(is.na(df_NEE$soil_temp_10_cm)) 
sum(is.na(df_NEE$inundated)) 
sum(is.na(df_NEE$air_temp)) 

```
#Summary of fluxes and enviro variables 

#Summarize by landscape position

```{r}
library(dplyr)
#NEE is in g/m2/s, convert back to umol (?) --> flux_value_umol
df_NEE$flux_value_umol <- df_NEE$flux_value *1/12 * 1000000 #same as flux_CO2

#generates Std.Error and Std.Dev for avgs of each site type to use for ggplot & 95% confidence interval calcs

landscape_NEE_summary <- df_NEE %>%
  select(landscape_position, inundated, flux_value, flux_value_umol, thawdepth, soil_temp_10_cm, air_temp, VWC) %>%
  group_by(landscape_position) %>%
  summarise(across(where(is.numeric), #chooses only numeric columns 
                   list(mean = ~mean(., na.rm = TRUE), # ~ means function, "." means apply to each current column
                        sd = ~sd(., na.rm = TRUE), # Standard deviation (describe spread)
                        n = ~sum(!is.na(.)),
                        se = ~sd(., na.rm = TRUE) / sqrt(sum(!is.na(.))) # Standard error (inference about mean)
                   ),
                   .names = "{.col}_{.fn}"),
            .groups = "drop")


#format table, round to 2 decimal places --> this rounds flux value into 0.00 so we need to exclude it 
landscape_NEE_summary_rounded <- landscape_NEE_summary  %>%
  mutate(across(where(is.numeric), ~round(., 2)))

#exclude flux value from rounding 
landscape_NEE_summary_rounded <- landscape_NEE_summary  %>%
  mutate(across(
    where(is.numeric) & !starts_with("flux_value"), #the ! means to omit, so omits any columns starting with this word
    ~round(., 2)
  ))


#OR use this, to round to 2 sig digits
landscape_NEE_summary_rounded2 <- landscape_NEE_summary  %>%
  mutate(across(where(is.numeric), ~signif(., 3)))


#combine to round enviro vars to 2 decimals and flux values to 2 sig digits so they're all formatted similarly in output -- flux-value_umol rounded to 2 decimals 
landscape_NEE_summary_rounded3 <- landscape_NEE_summary %>%
  mutate(
    across(
      where(is.numeric) & !starts_with("flux_value"),
      ~round(., 2)
    ),
     # flux_value_umol_* → round to 2 decimal places (keep numeric)
    across(
      c(flux_value_umol_mean, flux_value_umol_sd, flux_value_umol_se),
      ~round(., 2)
    ),
    across(
      c(flux_value_mean, flux_value_sd, flux_value_se), #rounds fluxes to 2 sig digits
      ~formatC(., format = "e", digits = 2)
    )
  )



write.csv(landscape_NEE_summary_rounded3, "C:/Users/kkent/Documents/Council Data/Soil Chambers_Council/landscape_NEEflux_summary_rounded.csv", row.names = FALSE)

```

#Table: Summarize by landscape position and inundated or not 

```{r}
library(dplyr)
#generates Std.Error and Std.Dev for avgs of each site type to use for ggplot & 95% confidence interval calcs

landscapeinun_NEE_summary <- df_NEE %>%
  select(landscape_position, inundated, flux_value, flux_value_umol, thawdepth, soil_temp_10_cm, air_temp, VWC) %>%
  group_by(landscape_position, inundated) %>%
  summarise(across(where(is.numeric),
                   list(mean = ~mean(., na.rm = TRUE), # ~ means function, "." means apply to each current column
                        sd = ~sd(., na.rm = TRUE), # Standard deviation (describe spread)
                        n = ~sum(!is.na(.)),
                        se = ~sd(., na.rm = TRUE) / sqrt(sum(!is.na(.))) # Standard error (inference about mean)
                   ),
                   .names = "{.col}_{.fn}"),
            .groups = "drop")


#format table, round to 2 decimal places --> this rounds flux value into 0.00 so we need to exclude it 
landscapeinun_NEE_summary_rounded <- landscapeinun_NEE_summary  %>%
  mutate(across(where(is.numeric), ~round(., 2)))

#exclude flux value from rounding 
landscapeinun_NEE_summary_rounded <- landscapeinun_NEE_summary  %>%
  mutate(across(
    where(is.numeric) & !starts_with("flux_value"), #the ! means to omit, so omits any columns starting with this word
    ~round(., 2)
  ))


#OR use this, to round to 2 sig digits
landscapeinun_NEE_summary_rounded2 <- landscapeinun_NEE_summary  %>%
  mutate(across(where(is.numeric), ~signif(., 3)))


#combine to round enviro vars to 2 decimals and flux values to 2 sig digits so they're all formatted similarly in output
landscapeinun_NEE_summary_rounded3 <- landscapeinun_NEE_summary %>%
  mutate(
    across(
      where(is.numeric) & !starts_with("flux_value"),
      ~round(., 2)
    ),
      # flux_value_umol_* → round to 2 decimal places (keep numeric)
    across(
      c(flux_value_umol_mean, flux_value_umol_sd, flux_value_umol_se),
      ~round(., 2)
    ),
    across(
      c(flux_value_mean, flux_value_sd, flux_value_se), #rounds fluxes to 2 sig digits
      ~formatC(., format = "e", digits = 2)
    )
  )



write.csv(landscapeinun_NEE_summary_rounded3, "C:/Users/kkent/Documents/Council Data/Soil Chambers_Council/landscapeinun_NEEflux_summary_rounded.csv", row.names = FALSE)


#format table so mean and SE occur in same line with +/- 

library(tidyr)
library(dplyr)

landscapeinun_NEE_summary_combined <- landscapeinun_NEE_summary_rounded3%>%
    mutate(
    flux_value= paste0(flux_value_mean, " ± ", flux_value_se),
    flux_value_umol= paste0(flux_value_umol_mean, " ± ", flux_value_umol_se), #rounds flux umol to 2 decimal places 
    thawdepth = paste0(thawdepth_mean, " ± ", thawdepth_se),
    VWC = paste0(VWC_mean, " ± ", VWC_se),
    soil_temp = paste0(soil_temp_10_cm_mean, " ± ", soil_temp_10_cm_se),
    air_temp = paste0(air_temp_mean, " ± ", air_temp_se)
    # Continue for any others you'd like to combine
  ) %>%
   ungroup() %>%
  select(landscape_position, inundated, flux_value, flux_value_umol, thawdepth, VWC, soil_temp, air_temp, ends_with("_n")) #ends with _n keeps columns with datapoint count for each var 

write.csv(landscapeinun_NEE_summary_combined, "C:/Users/kkent/Documents/Council Data/Soil Chambers_Council/landscapeinun_NEEflux_summary_combined2.csv", row.names = FALSE)

```




# Categorical Predictors: Variance and normality of categorical predictor variables 
```{r}
#Flux and landscape pos
df_variance_landpos <- df_NEE %>%
  group_by(landscape_position) %>%
  summarize(variance = var(flux_value, na.rm = TRUE))

print(df_variance_landpos)

# Variance plot - flux and landscape pos
ggplot(df_variance_landpos, aes(x = landscape_position, y = variance)) +
  geom_bar(stat = "identity") +
  theme_minimal() +
  labs(title = "Variance of Flux Value by Landscape Position",
       y = "Variance")
#higher variance in upland 


#Flux and inundated 
df_variance_inundated <- df_NEE %>%
  group_by(inundated) %>%
  summarize(variance = var(flux_value, na.rm = TRUE))

print(df_variance_inundated)

# Variance plot - flux and inundated
ggplot(df_variance_inundated, aes(x = inundated, y = variance)) +
  geom_bar(stat = "identity") +
  theme_minimal() +
  labs(title = "Variance of Flux Value by Inundation",
       y = "Variance")
#higher variance in NOT* inundated plots 


# Shapiro-Wilk test for normality across entire dataset
shapiro_test <- shapiro.test(df_NEE$flux_value)
print(shapiro_test) #p<0.001, not normal 


# Test normality within each landscape position
df_NEE %>%
  group_by(landscape_position) %>%
  summarize(
    shapiro_p = shapiro.test(flux_value)$p.value,
    normal = ifelse(shapiro_p > 0.05, "Yes", "No")
      )
#Results: lowland & upland = no; slope = yes


# Test normality based on inundated
df_NEE %>%
  group_by(inundated) %>%
  summarize(
    shapiro_p = shapiro.test(flux_value)$p.value,
    normal = ifelse(shapiro_p > 0.05, "Yes", "No")
      )
#Results: N = no; Y = no 


# Q-Q plot of full dataset 
qqnorm(df_NEE$flux_value)
qqline(df_NEE$flux_value, col = "red")


#histograms with density curves by landscape position
ggplot(df_NEE, aes(x = flux_value, fill = landscape_position)) +
  geom_histogram(aes(y = ..density..), alpha = 0.5, position = "identity", bins = 30) +
  geom_density(alpha = 0.2) +
  facet_wrap(~landscape_position) +
  theme_minimal() +
  labs(title = "Distribution of NEE by Landscape Position")


# histograms with density curves by inundated
ggplot(df_NEE, aes(x = flux_value, fill = inundated)) +
  geom_histogram(aes(y = ..density..), alpha = 0.5, position = "identity", bins = 30) +
  geom_density(alpha = 0.2) +
  facet_wrap(~inundated) +
  theme_minimal() +
  labs(title = "Distribution of NEE by Inundation")



#homogeneity of variance - levene's test
# p > 0.05: Variances are homogeneous (no significant difference between variances).
# p ≤ 0.05: Variances are not homogeneous.
library(car)

# Test homogeneity of variance for all main factors
leveneTest(flux_value ~ landscape_position, data = df_NEE) #p=0.35, homogeneity of var is ok
leveneTest(flux_value ~ inundated, data = df_NEE)#p = 0.66, ok


#for interactions
leveneTest(flux_value ~ landscape_position * inundated, data = df_NEE) #p=0.7, ok

```

#Continuous predictors: Variance and normality of continuous predictor variables 

###Testing to see which kind of correlation to use: Pearson for parametric, Spearman for non-parametric
```{r}
#test distribution normality of each numeric predictor variable 
shapiro.test(df_NEE$soil_temp_10_cm) #p=0.004, NOT normal** 
shapiro.test(df_NEE$thawdepth) #p = <0.001, NOT normal **
shapiro.test(df_NEE$VWC) #p<0.001, NOT normal **
shapiro.test(df_NEE$air_temp) #p=0.0025, not normal**

#visualize pairs to see if it looks linear
pairs(df_NEE[c("soil_temp_10_cm", "thawdepth", "VWC")]) #NOPE 

plot(df_NEE$soil_temp_10_cm, df_NEE$thawdepth)

plot(df_NEE$soil_temp_10_cm, df_NEE$VWC)

plot(df_NEE$thawdepth, df_NEE$VWC)

plot(df_NEE$soil_temp_10_cm, df_NEE$air_temp) #looks like it, expected 

plot(df_NEE$air_temp, df_NEE$thawdepth)

plot(df_NEE$air_temp, df_NEE$VWC)

ggplot(df_NEE, aes(x = soil_temp_10_cm, y = thawdepth))+
  geom_point()+
    labs(
     x = "Soil Temperature (10 cm)", 
     y = "Thaw Depth")+
geom_abline(intercept = 0, slope = 7, color = "red") # 1:1 line in red, adj slope to account for diffs in scale


#So this means for correlations and looking at collinearity, I need to use non-parametric tests 


#Check homogeneity of variance: should see even spread of of points for homogeneity of variance 

# Fit a simple model
simple_model <- lm(flux_value ~ thawdepth, data = df_NEE)

# Extract fitted values and residuals
fitted_values <- fitted(simple_model)
residuals <- residuals(simple_model)

# Plot residuals vs. predictor
plot(df_NEE$thawdepth, residuals, 
     xlab = "Cont. Pred. Var", ylab = "Residuals",
     main = "Residuals vs. Predictor Var")
abline(h = 0, lty = 2)

# Create a scale-location plot --> should be randomly scattered with a relatively flat trend line (red) for homogeneity of variance 
plot(simple_model, which = 3)


#Breusch-Pagan test - specifically tests if variance of residuals is constant - want a p > 0.05 for homogeneity of var
library(lmtest)
bptest(simple_model)

#thawdepth = p=0.77, shows there is homogeneity of var 
#soil temp = p = 0.4, suggests homogeneity of var 
#VWC = p = 0.34,  suggests homogeneity of var 

```
#Just looking at variables 
```{r}
ggplot(df_NEE, aes(x = soil_temp_10_cm, y = thawdepth)) +
  geom_point() +
  labs(
    x = "Soil Temperature (10 cm)", 
    y = "Thaw Depth (cm)", 
    title = "Scatterplot of Soil Temperature vs. Thaw Depth") +
  geom_smooth(method = "lm", color = "red") +
  geom_abline(intercept = 0, slope = 7, color = "blue", linetype = "dashed")

```


#Checking colinearity / correlations to determine which variables to use for models 

#Non-parametric tests of correlations - spearman's correlation 

#Corr of continuous variables 
```{r}
#Correlation between soil temp, thaw depth, and VWC

cor.test(df_NEE$soil_temp_10_cm, df_NEE$thawdepth, method="spearman")#p=0.01, *SIG*, correlated
cor.test(df_NEE$soil_temp_10_cm, df_NEE$VWC, method="spearman") #p<0.01, *Sig*, correlated, one should be removed 
cor.test(df_NEE$thawdepth, df_NEE$VWC, method="spearman") #p<0.001, *sig*, correlated, one should be removed 

cor.test(df_NEE$soil_temp_10_cm, df_NEE$air_temp, method="spearman")#p<0.001, correlated*

cor.test(df_NEE$air_temp, df_NEE$VWC, method="spearman")#p=0.14, not correlated  

cor.test(df_NEE$air_temp, df_NEE$thawdepth, method="spearman")#p=0.59, not correlated 


#Shows thawdepth and VWC are correlated, and VWC & soil temp are correlated 
```

#Checking correlation in categorical variables 
```{r}
# Check for separation in categorical variables
table(df_NEE$landscape_position, df_NEE$inundated) 


# Create contingency table to examine correlation quantitatively / confirm the separation test above 
cont_table <- table(df_NEE$landscape_position, df_NEE$inundated)
print(cont_table)

# Test for association
chisq.test(cont_table) #p<0.001--> correlated
# Or for small sample sizes
fisher.test(cont_table) #p=0.001, correlated 

#landpos and inun are correlated, will remove inun 

```

#Determining model for landscape NEE


#Step 1: Determine which of the correlated variables to keep
```{r}
# Create competing models with one variable at a time - use "ML" to compare models, use "REML" for fitting final model 

#thawdepth and VWC are correlated, and VWC & soil temp are correlated, air & soil temp are correlated  
model_temp <- gls(flux_value ~ landscape_position + soil_temp_10_cm, 
                 data = df_NEE, method = "ML")

model_thaw <- gls(flux_value ~ landscape_position + thawdepth, 
                 data = df_NEE, method = "ML")

model_VWC <- gls(flux_value ~ landscape_position + VWC, 
                 data = df_NEE, method = "ML")

model_airtemp <- gls(flux_value ~ landscape_position + air_temp, 
                 data = df_NEE, method = "ML")

model_soiltempthawdepth1 <- gls(flux_value ~ landscape_position + thawdepth + soil_temp_10_cm, 
                 data = df_NEE, method = "ML")



# Compare with AIC/BIC
AIC(model_temp, model_thaw, model_VWC, model_airtemp, model_soiltempthawdepth1) 

BIC(model_temp, model_thaw, model_VWC, model_airtemp, model_soiltempthawdepth1)

#model_airtemp lowest AIC/BIC, followed by model_VWC  

```

#Step 2: Now, test whether adding soil temp or thaw depth improves model 
```{r}
#start with the two best predictor variables from prev code chunk 

model_airtemp <- gls(flux_value ~ landscape_position + air_temp,
                        data = df_NEE, method = "ML")


model_airtempsoiltemp <- gls(flux_value ~ landscape_position + air_temp + soil_temp_10_cm,
                        data = df_NEE, method = "ML")

anova(model_airtemp, model_airtempsoiltemp)#p=0.38, adding soil temp does not improve model 


model_airtempVWC<- gls(flux_value ~ landscape_position + air_temp + VWC,
                        data = df_NEE, method = "ML")

anova(model_airtemp,model_airtempVWC)#p=0.16, adding VWC does not improve model 


model_airtempthaw<- gls(flux_value ~ landscape_position + air_temp + thawdepth,
                        data = df_NEE, method = "ML")

anova(model_airtemp,model_airtempthaw)#p=0.34, adding thawdepth does not improve model




model_VWC <- gls(flux_value ~ landscape_position + VWC,
                        data = df_NEE, method = "ML")

model_VWCsoiltemp <- gls(flux_value ~ landscape_position + VWC + soil_temp_10_cm,
                        data = df_NEE, method = "ML")

anova(model_VWC, model_VWCsoiltemp) #p=0.27, adding soil temp does not improve model 


model_VWCthawdepth <- gls(flux_value ~ landscape_position + VWC + thawdepth,
                        data = df_NEE, method = "ML")

anova(model_VWC, model_VWCthawdepth) #p=0.3, adding thawdepth does not improve model 

anova(model_VWCsoiltemp, model_VWCthawdepth) #essentially the same, no p  

#Appears neither thaw depth or soil temp improve model, VWC is best

anova(model_VWC, model_airtemp) #no p, no sig diff between these two models, but model_airtemp has lower AIC/BIC, higher LogLik 


```

#Step 3: Test if random effect of plot_ID or plot_type is appropriate
```{r}
#Use best predictor variable from Step 1, which was airtemp or VWC
#use 'ML' for comparing models 

library(nlme)

# air temp 

#gls - no random effect
model_fixed <- gls(flux_value ~ landscape_position + air_temp, 
                  data = df_NEE, method = "ML")

#lme - with random effect of plot_ID
model_random <- lme(flux_value ~ landscape_position + air_temp, 
                   random = ~1|plot_ID, 
                   data = df_NEE, method = "ML")

# Compare
anova(model_fixed, model_random) #p=0.99, random effect does not improve model  

#lme - with random effect of plot type 
model_random2 <- lme(flux_value ~ landscape_position + air_temp, 
                   random = ~1|plot_type, 
                   data = df_NEE, method = "ML")

# Compare
anova(model_fixed, model_random2) #p=0.99, random effect of plot type does not improve model 

#go with no random effect 



#VWC

#gls - no random effect
model_fixed <- gls(flux_value ~ landscape_position + VWC, 
                  data = df_NEE, method = "ML")

#lme - with random effect of plot_ID
model_random <- lme(flux_value ~ landscape_position + VWC, 
                   random = ~1|plot_ID, 
                   data = df_NEE, method = "ML")

# Compare
anova(model_fixed, model_random) #no sig diff and AIC/BIC marginally lower in model-fixed, p=0.99, so go for simpler model without random effect 

#lme - with random effect of plot type 
model_random2 <- lme(flux_value ~ landscape_position + VWC, 
                   random = ~1|plot_type, 
                   data = df_NEE, method = "ML")

# Compare
anova(model_fixed, model_random2) #p=0.99, random effect of plot type does not improve model 

```

#Step 4: Test for variance structure 

#### with airtemp 
```{r}
# test if adding a variance structure is appropriate 
model_homoscedastic <- gls(flux_value ~ landscape_position + air_temp, 
                          data = df_NEE, method = "ML")

model_heteroscedastic <- gls(flux_value ~ landscape_position + air_temp, 
                            weights = varIdent(form = ~1|landscape_position),
                            data = df_NEE, method = "ML")


# Compare
anova(model_homoscedastic, model_heteroscedastic) #p=<0.001 SIG*; hetero has lower AIC/BIC and higher LogLik, var structure does improve the model 

model_heteroscedastic2 <- gls(flux_value ~ landscape_position + air_temp, 
                            weights = varIdent(form = ~1|plot_type),
                            data = df_NEE, method = "ML")
# Compare
anova(model_homoscedastic, model_heteroscedastic2) #p<0.001, model improves with plot type var structure 
anova(model_heteroscedastic, model_heteroscedastic2)#no p, appears using plot type var structure (hetero2) may be better fit, lower AIC/BIC, higher logLik


model_heteroscedastic3 <- gls(flux_value ~ landscape_position + air_temp, 
                            weights = varComb(varIdent(form = ~1|plot_type),varIdent(form = ~ 1 |                                             landscape_position)),
                            data = df_NEE, method = "ML")

anova(model_homoscedastic, model_heteroscedastic3) # hetero3 p<0.001, hetero3 better model 
anova(model_heteroscedastic2, model_heteroscedastic3)#p<0.001, hetero3 better model 
```

#### with VWC 
```{r}
# test if adding a variance structure is appropriate 
model_homoscedastic <- gls(flux_value ~ landscape_position + VWC, 
                          data = df_NEE, method = "ML")
anova(model_homoscedastic, type = "marginal", test = TRUE)#none sig 


model_heteroscedastic <- gls(flux_value ~ landscape_position + VWC, 
                            weights = varIdent(form = ~1|landscape_position),
                            data = df_NEE, method = "ML")
anova(model_heteroscedastic, type = "marginal", test = TRUE)#none sig 

# Compare
anova(model_homoscedastic, model_heteroscedastic) #p=<0.001 SIG*; hetero has lower AIC/BIC and higher LogLik so we do use a variance structure here * 


model_heteroscedastic2 <- gls(flux_value ~ landscape_position + VWC, 
                            weights = varIdent(form = ~1|plot_type),
                            data = df_NEE, method = "ML")
anova(model_heteroscedastic2, type = "marginal", test = TRUE)#landpos p<0.01, SIG*

# Compare
anova(model_homoscedastic, model_heteroscedastic2) #p<0.001, model improves with plot type var structure 
anova(model_heteroscedastic, model_heteroscedastic2)#appears using plot type var structure may be better fit, lower AIC/BIC, higher logLik


model_heteroscedastic3 <- gls(flux_value ~ landscape_position + VWC, 
                            weights = varComb(varIdent(form = ~1|plot_type),varIdent(form = ~ 1 |                                             landscape_position)),
                            data = df_NEE, method = "ML")
#anova(model_heteroscedastic3, type = "marginal", test = TRUE)#landpos p=0.002, SIG*
                            
                            #varComb(varIdent(form = ~ 1| inundated), varIdent(form = ~ 1 | landscape_position)))

anova(model_homoscedastic, model_heteroscedastic3) # hetero3 p<0.001, hetero3 better model 
anova(model_heteroscedastic2, model_heteroscedastic3)#p<0.001, hetero3 better model 
```
####air_temp vs VWC with var structure 
```{r}
model_VWCheteroscedastic3 <- gls(flux_value ~ landscape_position + VWC, 
                            weights = varComb(varIdent(form = ~1|plot_type),varIdent(form = ~                              1 |  landscape_position)),
                            data = df_NEE, method = "ML")

model_airtempheteroscedastic3 <- gls(flux_value ~ landscape_position + air_temp, 
                            weights = varComb(varIdent(form = ~1|plot_type),varIdent(form = ~                              1 | landscape_position)),
                            data = df_NEE, method = "ML")

anova(model_VWCheteroscedastic3, model_airtempheteroscedastic3) #no p, but airtemp model has lower AIC/BIC 
```

#Step 5: Try adding any remaining (non)-correlated variables back in to see if it improves the model (use reduction and addition / reduced models to test if various un-correlated predictors improve the model or not, and favor the simpler model) - try correlated vars too, just to see, but check VIF***


#Multiple var structure with landpos and plot type 

####air temp 
```{r}
#combined var structure as suggested may improve the model 
# test variable soil temp (but this was correlated with VWC, just running to check if var structure changes this)
model_1varAirT <- gls(flux_value ~ landscape_position + air_temp, 
                weights = varComb(varIdent(form = ~1|plot_type),varIdent(form = ~ 1 |                                             landscape_position)),
                 data = df_NEE, method = "ML")

model_2var <- gls(flux_value ~ landscape_position + air_temp + soil_temp_10_cm, 
                weights = varComb(varIdent(form = ~1|plot_type),varIdent(form = ~ 1 |                                             landscape_position)),
                 data = df_NEE, method = "ML")

# Compare
anova(model_1varAirT, model_2var) #p=0.8, adding soil temp does not improve model, and they were correlated anyhow  

#try variable thawdepth 
model_2var <- gls(flux_value ~ landscape_position + air_temp + thawdepth, 
                 weights = varComb(varIdent(form = ~1|plot_type),varIdent(form = ~ 1 |                                             landscape_position)),
                 data = df_NEE, method = "ML")

# Compare
anova(model_1varAirT, model_2var) #p=0.1, adding thawdepth does not improve model 


#add VWC
model_2var <- gls(flux_value ~ landscape_position + air_temp + VWC, 
                 weights = varComb(varIdent(form = ~1|plot_type),varIdent(form = ~ 1 |                                             landscape_position)),
                 data = df_NEE, method = "ML")

# Compare
anova(model_1varAirT, model_2var) #p=0.65, adding VWC does not improve model

#add inundated 
model_2var <- gls(flux_value ~ landscape_position + air_temp + inundated, 
                 weights = varComb(varIdent(form = ~1|plot_type),varIdent(form = ~ 1 |                                             landscape_position)),
                 data = df_NEE, method = "ML")

# Compare
anova(model_1varAirT, model_2var)#p=0.5, inundated does not improve model 


#air temp, VWC, thawdepth 
model_3var <- gls(flux_value ~ landscape_position + air_temp + VWC + thawdepth, 
               weights = varComb(varIdent(form = ~1|plot_type),varIdent(form = ~ 1 |                                             landscape_position)),
                 data = df_NEE, method = "ML")

anova(model_1varAirT, model_3var) #p=0.13, does not improve model 



#test interaction between landpos and VWC
model_interactVWC <- gls(flux_value ~ landscape_position * VWC + air_temp, 
                  weights = varComb(varIdent(form = ~1|plot_type),varIdent(form = ~ 1 |                                             landscape_position)),
                 data = df_NEE, method = "ML")

anova(model_1varAirT, model_interactVWC) #p=0.01, 1varAirT is better 

model_interactVWC2 <- gls(flux_value ~ landscape_position * VWC + air_temp + thawdepth, 
                  weights = varComb(varIdent(form = ~1|plot_type),varIdent(form = ~ 1 |                                             landscape_position)),
                 data = df_NEE, method = "ML")

anova(model_1varAirT, model_interactVWC2) #p=0.26, 1varAirT has lower AIC/BIC



model_3varinteract <- gls(flux_value ~ landscape_position + air_temp + VWC * thawdepth, 
               weights = varComb(varIdent(form = ~1|plot_type),varIdent(form = ~ 1 |                                             landscape_position)),
                 data = df_NEE, method = "ML")

anova(model_1varAirT, model_3varinteract)#p=0.18, no improvement 
```

#### VWC
```{r}
# test variable soil temp (but this was correlated with VWC, just running to check if var structure changes this)
model_1varVWC <- gls(flux_value ~ landscape_position + VWC, 
                weights = varComb(varIdent(form = ~1|plot_type),varIdent(form = ~ 1 |                                             landscape_position)),
                 data = df_NEE, method = "ML")

model_2var <- gls(flux_value ~ landscape_position + VWC + soil_temp_10_cm, 
                weights = varComb(varIdent(form = ~1|plot_type),varIdent(form = ~ 1 |                                             landscape_position)),
                 data = df_NEE, method = "ML")

# Compare
anova(model_1varVWC, model_2var) #p=0.02, *SIG, model 2var marginally better, suggests adding soil temp improves model 

#try variable thawdepth (but this was correlated with VWC)
model_2var <- gls(flux_value ~ landscape_position + VWC + thawdepth, 
                 weights = varComb(varIdent(form = ~1|plot_type),varIdent(form = ~ 1 |                                             landscape_position)),
                 data = df_NEE, method = "ML")

# Compare
anova(model_1varVWC, model_2var) #p=0.067, suggests thawdepth doesn't improve model 



#try variable thawdepth (but this was correlated with VWC)
model_2var <- gls(flux_value ~ landscape_position + VWC + air_temp, 
                 weights = varComb(varIdent(form = ~1|plot_type),varIdent(form = ~ 1 |                                             landscape_position)),
                 data = df_NEE, method = "ML")

# Compare
anova(model_1varVWC, model_2var)#p=0.001, adding air temp sig improves model 




#swap VWC for soil temp to check 
model_1varSoiltemp <- gls(flux_value ~ landscape_position + soil_temp_10_cm, 
                  weights = varComb(varIdent(form = ~1|plot_type),varIdent(form = ~ 1 |                                             landscape_position)),
                 data = df_NEE, method = "ML")

model_2var <- gls(flux_value ~ landscape_position + soil_temp_10_cm + VWC, 
                  weights = varComb(varIdent(form = ~1|plot_type),varIdent(form = ~ 1 |                                             landscape_position)),
                 data = df_NEE, method = "ML")

# Compare
anova(model_1varSoiltemp, model_2var) #p=0.49, no sig improvement from adding VWC to soil temp  

model_2var <- gls(flux_value ~ landscape_position + soil_temp_10_cm + thawdepth, 
                  weights = varComb(varIdent(form = ~1|plot_type),varIdent(form = ~ 1 |                                             landscape_position)),
                 data = df_NEE, method = "ML")

#compare 
anova(model_1varSoiltemp, model_2var)#p=0.3, no improvement from adding thaw depth to soil temp 


model_2var <- gls(flux_value ~ landscape_position + soil_temp_10_cm + air_temp, 
                  weights = varComb(varIdent(form = ~1|plot_type),varIdent(form = ~ 1 |                                             landscape_position)),
                 data = df_NEE, method = "ML")

#compare 
anova(model_1varSoiltemp, model_2var)#p=0.02, adding air temp sig improves model 


model_3var <- gls(flux_value ~ landscape_position + VWC + soil_temp_10_cm + air_temp, 
               weights = varComb(varIdent(form = ~1|plot_type),varIdent(form = ~ 1 |                                             landscape_position)),
                 data = df_NEE, method = "ML")

anova(model_1varVWC, model_3var) #p=0.007, model 3var is better 


model_4var <- gls(flux_value ~ landscape_position + VWC + soil_temp_10_cm + air_temp + thawdepth, 
               weights = varComb(varIdent(form = ~1|plot_type),varIdent(form = ~ 1 |                                             landscape_position)),
                 data = df_NEE, method = "ML")

anova(model_1varVWC, model_4var)#p=0.0028, model 4var is better 
anova(model_3var, model_4var)#p=0.04, model 4var is better 


model_5var <- gls(flux_value ~ landscape_position + VWC + soil_temp_10_cm + air_temp + thawdepth + inundated, 
               weights = varComb(varIdent(form = ~1|plot_type),varIdent(form = ~ 1 |                                             landscape_position)),
                 data = df_NEE, method = "ML")

anova(model_1varVWC, model_5var)#p=0.005, model 5var is better 
anova(model_5var, model_4var)#p=0.4, AIC/BIC lower for model 4var, 4var appears to be the better choice 



#test interaction between landpod and VWC, landpos and soil temp 
model_interactVWC <- gls(flux_value ~ landscape_position * VWC, 
                  weights = varComb(varIdent(form = ~1|plot_type),varIdent(form = ~ 1 |                                             landscape_position)),
                 data = df_NEE, method = "ML")

model_interactVWC2 <- gls(flux_value ~ landscape_position + VWC * thawdepth, 
                  weights = varComb(varIdent(form = ~1|plot_type),varIdent(form = ~ 1 |                                             landscape_position)),
                 data = df_NEE, method = "ML")

model_4varinteract <- gls(flux_value ~ landscape_position + VWC + soil_temp_10_cm * air_temp + thawdepth, 
               weights = varComb(varIdent(form = ~1|plot_type),varIdent(form = ~ 1 |                                             landscape_position)),
                 data = df_NEE, method = "ML")

# Compare
anova(model_1varVWC, model_interactVWC) #p=0.6, no improvement 
anova(model_1varVWC, model_interactVWC2) #p=0.13, no improvement 
anova(model_interactVWC2, model_1varVWC)#p=0.2, no improvement from adding thawdepth 
anova(model_4var, model_4varinteract)#p=0.69, no improvement from interaction, with and without including thawdepth 


#comparing the leading models 
m_soiltempVWC<- gls(flux_value ~ landscape_position + VWC + soil_temp_10_cm, 
                weights = varComb(varIdent(form = ~1|plot_type),varIdent(form = ~ 1 |                                             landscape_position)),
                 data = df_NEE, method = "ML")

m_soiltempVWCAirT<- gls(flux_value ~ landscape_position + VWC + soil_temp_10_cm + air_temp, 
                weights = varComb(varIdent(form = ~1|plot_type),varIdent(form = ~ 1 |                                             landscape_position)),
                 data = df_NEE, method = "ML")

m_VWCAirT<- gls(flux_value ~ landscape_position + VWC + air_temp, 
                weights = varComb(varIdent(form = ~1|plot_type),varIdent(form = ~ 1 |                                             landscape_position)),
                 data = df_NEE, method = "ML")

m_soiltemp<- gls(flux_value ~ landscape_position + soil_temp_10_cm, 
                weights = varComb(varIdent(form = ~1|plot_type),varIdent(form = ~ 1 |                                             landscape_position)),
                 data = df_NEE, method = "ML")

m_VWC<- gls(flux_value ~ landscape_position + VWC, 
                weights = varComb(varIdent(form = ~1|plot_type),varIdent(form = ~ 1 |                                             landscape_position)),
                 data = df_NEE, method = "ML")

model_1varAirT <- gls(flux_value ~ landscape_position + air_temp, 
                weights = varComb(varIdent(form = ~1|plot_type),varIdent(form = ~ 1 |                                             landscape_position)),
                 data = df_NEE, method = "ML")

model_4var <- gls(flux_value ~ landscape_position + VWC + soil_temp_10_cm + air_temp + thawdepth, 
               weights = varComb(varIdent(form = ~1|plot_type),varIdent(form = ~ 1 |                                             landscape_position)),
                 data = df_NEE, method = "ML")

 anova(m_soiltemp, m_VWC)#no p, but soiltemp marginally better
 anova(m_soiltemp, m_soiltempVWC) #p=0.49, no major improvement for adding VWC to soil temp 
 anova(m_soiltempVWC, m_soiltemp, m_VWC, model_1varAirT, model_4var, m_VWCAirT, m_soiltempVWCAirT)
 anova(model_1varAirT, model_4var)#p=0.22, 1varAirT seems slightly better 
anova(model_1varAirT, model_5var)#p=0.28, model_1varAirT slightly better 
anova(m_soiltempVWCAirT, model_1varAirT)#p=0.88 but var1 AirT has lower AIC/BIC 
```

#Step 6: Double check best correlated var was chosen, with and without extra var, now that variance structure was added 
```{r}
#test soil temp and thawdepth, and with and without VWC

model_airtemp <- gls(flux_value ~ landscape_position + air_temp, 
                       weights = varComb(varIdent(form = ~1|plot_type),varIdent(form = ~ 1 |                                             landscape_position)),
                 data = df_NEE, method = "ML")

model_soiltemp <- gls(flux_value ~ landscape_position + soil_temp_10_cm, 
                       weights = varComb(varIdent(form = ~1|plot_type),varIdent(form = ~ 1 |                                             landscape_position)),
                 data = df_NEE, method = "ML")

model_VWC <- gls(flux_value ~ landscape_position + VWC, 
                 weights = varComb(varIdent(form = ~1|plot_type),varIdent(form = ~ 1 |                                             landscape_position)),
                 data = df_NEE, method = "ML")

model_thawdepth <- gls(flux_value ~ landscape_position + thawdepth, 
                 weights = varComb(varIdent(form = ~1|plot_type),varIdent(form = ~ 1 |                                             landscape_position)),
                 data = df_NEE, method = "ML")

anova(model_airtemp, model_soiltemp) #airtemp better, no p 
anova(model_airtemp, model_VWC) #airtemp better, no p 
anova(model_airtemp, model_thawdepth) #airtemp slightly better, no p 
anova(model_soiltemp, model_thawdepth) #soiltemp better, no p
anova(model_soiltemp, model_VWC)  #soiltemp is better
anova(model_thawdepth, model_VWC) #thawdepth is better

#seems the 1varAirT model is best, using landpos and air temp, but model_4var may be viable too 
```


#Final model, refit with REML
```{r}
library(car)
#old, before adding in air temp 
# NEE.final <- gls(flux_value ~ landscape_position + soil_temp_10_cm, 
#                        weights = varComb(varIdent(form = ~1|plot_type),varIdent(form = ~ 1 |                                             landscape_position)),
#                  data = df_NEE, method = "REML")
# summary(NEE.final) #shows no var are sig 
# anova(NEE.final) #landpos sig, p = 0.001
# Anova(NEE.final, type = "II") #land pos p = 0.002, soil temp = 0.026 *SIG
# # Using the standard anova function with F tests
# anova(NEE.final, type = "marginal", test = TRUE) #land pos p = 0.002, soil temp = 0.026 *SIG
# 
# library(lsmeans)
# lsmeans(NEE.final, adjust = "Tukey", pairwise ~ landscape_position) 
# # lowland - slope  p=0.3623
# #  lowland - upland p= 0.0185 ** SIG
# #  slope - upland   p= 0.0109 **SIG
# 
# boxplot(flux_value ~ landscape_position, data = df_NEE)



NEE.final <- gls(flux_value ~ landscape_position + air_temp, 
                weights = varComb(varIdent(form = ~1|plot_type),varIdent(form = ~ 1 |                                             landscape_position)),
                 data = df_NEE, method = "REML")
summary(NEE.final) 
anova(NEE.final) #landpos p=0.001 *SIG, air temp p = 0.001, SIG*
Anova(NEE.final, type = "II") #land pos p<0.001; air temp = 0.001 *SIG
# Using the standard anova function with F tests
anova(NEE.final, type = "marginal", test = TRUE) #land pos p < 0.001, air temp = 0.001, *SIG

library(lsmeans)
lsmeans(NEE.final, adjust = "Tukey", pairwise ~ landscape_position)
# contrast          estimate       SE   df t.ratio p.value
#  lowland - slope  -4.94e-06 3.28e-06 34.8  -1.506  0.3005
#  lowland - upland  6.93e-06 2.29e-06 72.3   3.023  0.0096 ** SIG
#  slope - upland    1.19e-05 3.41e-06 40.0   3.479  0.0034 ** SiG 

boxplot(flux_value ~ landscape_position, data = df_NEE)


NEE.final2<- gls(flux_value ~ landscape_position + VWC + soil_temp_10_cm + air_temp + thawdepth, 
               weights = varComb(varIdent(form = ~1|plot_type),varIdent(form = ~ 1 |                                             landscape_position)),
                 data = df_NEE, method = "REML")
summary(NEE.final2) 
anova(NEE.final2, type = "marginal", test = TRUE) #landpos p = 0.0007 *SIG; VWC p = 0.21, soil temp p = 0.55, air temp p=0.005 *SIG, thawdepth p = 0.044 *SIG 

library(lsmeans)
lsmeans(NEE.final2, adjust = "Tukey", pairwise ~ landscape_position)
 # contrast          estimate       SE   df t.ratio p.value
 # lowland - slope  -5.39e-06 3.46e-06 37.7  -1.557  0.2767
 # lowland - upland  5.30e-06 2.70e-06 85.8   1.964  0.1274
 # slope - upland    1.07e-05 3.51e-06 40.3   3.050  0.0110 **SIG e

```


#Some extra exploratory validation tests (ignore this, based on singular var structure, leaving for reference)
```{r}
# m1 <- gls(flux_value ~ landscape_position + VWC, 
#                  weights = varIdent(form = ~1|landscape_position),
#                  data = df_NEE, method = "ML")
# summary(m1) #shows no var are sig 
# Anova(m1) #none sig 
# Anova(m1, type = "II", test.statistic = "F") #none sig 
# # Using the standard anova function with F tests
# anova(m1, type = "marginal", test = TRUE) #none sig 
# 
# 
# 
# m2 <- gls(flux_value ~ landscape_position + VWC + soil_temp_10_cm, 
#                  weights = varIdent(form = ~1|landscape_position),
#                  data = df_NEE, method = "ML")
# summary(m2) #shows no var are sig 
# Anova(m2) #none sig 
# Anova(m2, type = "II", test.statistic = "F") #none sig 
# # Using the standard anova function with F tests
# anova(m2, type = "marginal", test = TRUE) #none sig 
# 
# 
# 
# 
# m3 <- gls(flux_value ~ landscape_position + VWC + soil_temp_10_cm + thawdepth, 
#                  weights = varIdent(form = ~1|landscape_position),
#                  data = df_NEE, method = "ML")
# summary(m3) #shows no var are sig 
# Anova(m3) #none sig 
# Anova(m3, type = "II", test.statistic = "F") #none sig 
# # Using the standard anova function with F tests
# anova(m3, type = "marginal", test = TRUE) #none sig 
# 
# 
# anova(m1, m2) #p<0.4, m1 better, adding soil temp does not improve model 
# anova(m1, m3)#p<0.6, m1 better, adding thawdepth doesn't improve model 
```


#Step 7: Test for multicollinearity in model 

####For testing this in models, use VIF test 
```{r}
#variance inflation factor (vif) - vif = 1 = variables are not correlated; between 1 & 5 = moderately correlated,  5 or higher indicates highly correlated & multicollinearity among variables. GVIF is a generalized VIF for categorical variables with more than two levels; the adj VIF gives values for comparing across variables with diff degrees of freedom* --> look at both when assessing collinearity in a model 
library(car)
vif(NEE.final) # all <2, so should be ok! 
```

Plot model residuals and QQplot 
```{r}
#plot model residuals (homogeneity of variance)
plot(NEE.final)

#qqplot to verify normality - this plots the actual model, not the residuals 
qqnorm(NEE.final)

#checking how this QQ plot compares to plots created with normally distributed residuals

op <- par(mar = c(2,2,1,1), mfrow = c(5,5))

# create first qq plot using model residuals
# color it red
qqnorm(residuals(NEE.final), xlab = "", ylab = "", main = "", 
       col = "red")
qqline(residuals(NEE.final))

# now create 24 qq plots using Normal data with sigma(dataset)
for(i in 1:24){
  # rnorm() samples from a Normal distribution  
  d <- rnorm(length(residuals(NEE.final)), 
             mean = 0, sd = sigma(NEE.final))
  qqnorm(d, xlab = "", ylab = "", main = "")
  qqline(d)
}


#comparing data QQplot to a normal QQplot and hist 
qqnorm(residuals(NEE.final)) #normality of residuals 
hist(residuals(NEE.final)) 
car::qqPlot(x = residuals(NEE.final)) #shows where residuals breach normal distr
qqPlot(residuals(NEE.final))

```

#Normality of Residuals 
```{r}
#~~~~~~~~~NEE.final~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
# Extract standardized/normalized residuals
std_resid <- residuals(NEE.final, type = "normalized")

# Graphical assessment
par(mfrow = c(1, 2))
# Histogram of residuals
hist(std_resid, main = "Histogram of Standardized Residuals", 
     xlab = "Standardized Residuals", freq = FALSE)
curve(dnorm, add = TRUE, col = "red")

# QQ plot
qqnorm(std_resid, main = "Normal Q-Q Plot")
qqline(std_resid, col = "red")

# Formal test
shapiro_test <- shapiro.test(std_resid)
print(shapiro_test) #for gls final model: p<0.001; normality NOT supported 


#~~~~~~~~~~~~~~~~~~~~~~~~NEE.final2 ~~~~~~~~~~~~~~~~~~~~~~~~~~~
# Extract standardized/normalized residuals
std_resid2 <- residuals(NEE.final2, type = "normalized")

# Graphical assessment
par(mfrow = c(1, 2))
# Histogram of residuals
hist(std_resid2, main = "Histogram of Standardized Residuals", 
     xlab = "Standardized Residuals", freq = FALSE)
curve(dnorm, add = TRUE, col = "red")

# QQ plot
qqnorm(std_resid2, main = "Normal Q-Q Plot")
qqline(std_resid2, col = "red")

# Formal test
shapiro_test2 <- shapiro.test(std_resid2)
print(shapiro_test2) #for gls final model: p<0.001; normality NOT supported 

```


#Test autocorrelation
```{r}
# Extract normalized residuals from GLS model
residuals_gls <- residuals(NEE.final, type = "normalized")

# Plot the autocorrelation function
acf(residuals_gls, main = "Autocorrelation of Residuals") #want bars of Lag1 and higher to be below the blue-dotted lines of confidence -- ignore Lag0 ** Lag0 represents correlation of residuals with themselves and is always ~1, so this isn't useful and isn't a problem. Lag 1 shows corr between each residual and the prev residual, lag 2 = correlation between residuals 2 steps apart, etc. **Focus on Lag1 and higher* 

#one bar above dotted line 

# Compute lag-1 correlation in residuals - values close to 0 = little/no autocorrelation; value near 1 or -1 suggests sig correlation
cor(residuals_gls[-1], residuals_gls[-length(residuals_gls)]) 
#Result: 0.02, suggests no autocorrelation


# NEE.final2
residuals_gls2 <- residuals(NEE.final2, type = "normalized")

# Plot the autocorrelation function
acf(residuals_gls2, main = "Autocorrelation of Residuals") #one bar above blue line 

# Compute lag-1 correlation in residuals - values close to 0 = little/no autocorrelation; value near 1 or -1 suggests sig correlation
cor(residuals_gls2[-1], residuals_gls2[-length(residuals_gls2)]) 
#Result: 0.03, suggests no autocorrelation


vif(NEE.final) #all <2, ok

vif(NEE.final2) #all <2, ok 

```
#Homogeneity of variance 
```{r}
# Plot residuals vs fitted values
par(mfrow = c(1, 1))
plot(fitted(NEE.final), std_resid,
     xlab = "Fitted Values", ylab = "Standardized Residuals",
     main = "Residuals vs Fitted")
abline(h = 0, lty = 2)

#NEE.final2
par(mfrow = c(1, 1))
plot(fitted(NEE.final2), std_resid2,
     xlab = "Fitted Values", ylab = "Standardized Residuals",
     main = "Residuals vs Fitted")
abline(h = 0, lty = 2)

# Check residuals by predictor variables
par(mfrow = c(2, 2))
boxplot(std_resid ~ df_NEE$landscape_position, 
        main = "Residuals by Landscape Position")
abline(h = 0, lty = 2)

boxplot(std_resid ~ df_NEE$inundated, 
        main = "Residuals by Inundation")
abline(h = 0, lty = 2)

plot(df_NEE$soil_temp_10_cm, std_resid,
     xlab = "Soil Temperature (10 cm)", ylab = "Standardized Residuals")
abline(h = 0, lty = 2)

# Residuals vs. Fitted plot
plot(fitted(NEE.final), std_resid, 
     xlab = "Fitted Values", ylab = "Residuals",
     main = "Residuals vs Fitted Values")
abline(h = 0, col = "red", lty = 2)

# Residuals vs. Fitted plot - NEE.final2
plot(fitted(NEE.final2), std_resid2, 
     xlab = "Fitted Values", ylab = "Residuals",
     main = "Residuals vs Fitted Values")
abline(h = 0, col = "red", lty = 2)

# Levene’s Test for Homogeneity of Variance
library(car)
leveneTest(std_resid ~ df_NEE$landscape_position) #NEE.final p=0.55; ok 
leveneTest(std_resid2 ~ df_NEE$landscape_position) #for NEE.final2 p=0.57; ok 

```
#Non-parametric approach 

#### Important to note KW test is the non-parametric equivalent of a one-way anova, so it can only test one variable at a time, and can't test continuous/numeric variables. It also can't incorporate a variance structure. Spearman Correlation can be used for continuous variables*
#testing each var independently isn't ideal because it can't capture what might happen when other variables are included...
```{r}
# Test landscape position effect on NEE
kruskal.test(flux_value ~ landscape_position, data = df_NEE) #p=0.058, not sig/marginal  

#wilcoxon test
# For comparing two landscape positions (unpaired)
wilcox.test(flux_value ~ landscape_position, 
            data = df_NEE,
            subset = landscape_position %in% c("upland", "lowland")) #p=0.13, not sig 

wilcox.test(flux_value ~ landscape_position, 
            data = df_NEE,
            subset = landscape_position %in% c("upland", "slope"))#p=0.04, *SIG 

wilcox.test(flux_value ~ landscape_position, 
            data = df_NEE,
            subset = landscape_position %in% c("slope", "lowland"))#p=0.13, not sig 


# For continuous variables, use Spearman correlation
cor.test(df_NEE$flux_value, df_NEE$air_temp, method = "spearman") #p=0.02, SIG*
cor.test(df_NEE$flux_value, df_NEE$soil_temp_10_cm, method = "spearman") #p=0.27, not sig
cor.test(df_NEE$flux_value, df_NEE$VWC, method = "spearman") #p=0.23, not sig 
cor.test(df_NEE$flux_value, df_NEE$thawdepth, method = "spearman") #p=0.037, *SIG* -> but correlated with VWC so not trusting this...? 


```
#Robust Regression - less sensitive to violations of normality but cannot incorporate variance structure**
```{r}
library(MASS)
library(car)
#just testing reduced and full models - cross-validating 

robust_model.final <- rlm(flux_value ~ landscape_position + air_temp, 
                    data = df_NEE)
summary(robust_model.final) 
Anova(robust_model.final, type = "II") #landpos = 0.022, *SIG*; airtemp p = 0.005 *SIG*

vif(robust_model.final)#all <2, ok

robust_model.final2 <- rlm(flux_value ~ landscape_position + air_temp + VWC + soil_temp_10_cm + thawdepth, 
                    data = df_NEE)
summary(robust_model.final2) 
Anova(robust_model.final2, type = "II") #landpos = 0.054 *marginal; air temp p =<0.001 *SIG, VWCp = 0.02 *SIG, soil temp p = 0.13, thawdepth p = 0.003 *SIG 

vif(robust_model.final2)#all <2, ok


robust_model1 <- rlm(flux_value ~ landscape_position + soil_temp_10_cm, 
                    data = df_NEE)
summary(robust_model1) 
Anova(robust_model1, type = "II") #landpos = 0.03, *SIG*
vif(robust_model1)# all <2, ok 

robust_model2 <- rlm(flux_value ~ landscape_position + VWC, 
                    data = df_NEE)
summary(robust_model2) 
Anova(robust_model2, type = "II") #landpos p = 0.03, *SIG


robust_model3 <- rlm(flux_value ~ landscape_position + soil_temp_10_cm + VWC, 
                    data = df_NEE)
summary(robust_model3) 
Anova(robust_model3, type = "II") #landpos p=0.028, *SIG*
vif(robust_model3)# all <2, ok 


robust_model4 <- rlm(flux_value ~ landscape_position + VWC + soil_temp_10_cm + air_temp,
                    data = df_NEE)
summary(robust_model4) 
Anova(robust_model4, type = "II") #landpos p=0.02 *SIG, airtemp p = 0.007 *SIG



robust_model_all <- rlm(flux_value ~ landscape_position + VWC + soil_temp_10_cm + air_temp + thawdepth + inundated,
                    data = df_NEE)
summary(robust_model_all) 
Anova(robust_model_all, type = "II") #landpos p=0.02 *SIG, airtemp p = 0.007 *SIG
vif(robust_model_all)# all <2, ok 

#                    Df       F    Pr(>F)    
# landscape_position   2  2.9341 0.0562401 .  
# VWC                  1  5.6501 0.0187161 *  
# soil_temp_10_cm      1  2.4136 0.1223915    
# air_temp             1 12.2907 0.0006006 ***
# thawdepth            1  8.3620 0.0044015 ** 
# inundated            1  0.0619 0.8038304    
# Residuals          150 


robust_model.landpos <- rlm(flux_value ~ landscape_position, 
                    data = df_NEE)
summary(robust_model.landpos) 
Anova(robust_model.landpos, type = "II")
#                     Df     F  Pr(>F)  
# landscape_position   2 3.515 0.03214 * --> SIG
# Residuals          155 

```


#Attempting to test robust regression models - coding help from Claude 
```{r}
# Define a function to calculate AIC for robust regression
rlm_AIC <- function(model) {
  n <- length(model$residuals)
  RSS <- sum(model$residuals^2)
  k <- length(coef(model)) + 1  # +1 for the error variance
  AIC <- n * log(RSS/n) + 2*k
  return(AIC)
}

# Compare models
rlm_AIC(robust_model.final)
rlm_AIC(robust_model.final2)
rlm_AIC(robust_model1)
rlm_AIC(robust_model2)
rlm_AIC(robust_model3)
rlm_AIC(robust_model4)
rlm_AIC(robust_model_all)

#Results:
# [1] -3420.771
# [1] -3420.281
# [1] -3414.906 -->marginally second best, model 1 with landpos and soil temp
# [1] -3415.374
# [1] -3414.686 --> marginally best - model 3 - landpos, soil temp and VWC 
# [1] -3418.991
# [1] -3418.529

```

#attempting post-hoc to determine which landpos differ from each other
```{r}
#claude helped with coding several approaches but nothing worked :( 

#found this online, seems to work? not sure if it accounts for the soil temp though**
# Perform post-hoc Tukey test
tukey_results <- emmeans(robust_model.final, "landscape_position", type = "marginal")
tukey_pairwise <- pairs(tukey_results, adjust = "tukey")
print(tukey_pairwise)
#lowland-slope p = 0.29, not sig
#lowland - upland p=0.34, not sig 
#slope-upland p = 0.018 *SIG* --> matches what the wilcoxon paired tests found ** 

#NEE.final2
tukey_results2 <- emmeans(robust_model.final2, "landscape_position", type = "marginal")
tukey_pairwise2 <- pairs(tukey_results2, adjust = "tukey")
print(tukey_pairwise2)
 # contrast          estimate       SE df z.ratio p.value
 # lowland - slope  -3.55e-06 3.08e-06 NA  -1.151  0.4825
 # lowland - upland  2.91e-06 2.31e-06 NA   1.257  0.4195
 # slope - upland    6.45e-06 2.75e-06 NA   2.345  0.0499 --> marginal / sig * 


#robust_model3
tukey_results3 <- emmeans(robust_model3, "landscape_position", type = "marginal")
tukey_pairwise3 <- pairs(tukey_results3, adjust = "tukey")
print(tukey_pairwise3)
 # contrast          estimate       SE df z.ratio p.value
 # lowland - slope  -2.62e-06 3.19e-06 NA  -0.821  0.6899
 # lowland - upland  4.27e-06 2.36e-06 NA   1.806  0.1677
 # slope - upland    6.89e-06 2.86e-06 NA   2.412  0.0419 --> *SIG

#robust_model1
tukey_results1 <- emmeans(robust_model1, "landscape_position", type = "marginal")
tukey_pairwise1 <- pairs(tukey_results1, adjust = "tukey")
print(tukey_pairwise1)
 # contrast          estimate       SE df z.ratio p.value
 # lowland - slope  -4.01e-06 3.10e-06 NA  -1.294  0.3988
 # lowland - upland  3.23e-06 2.24e-06 NA   1.443  0.3187
 # slope - upland    7.24e-06 2.85e-06 NA   2.542  0.0297 --> SIG*

#robust_model_all
tukey_results_all <- emmeans(robust_model_all, "landscape_position", type = "marginal")
tukey_pairwise_all <- pairs(tukey_results_all, adjust = "tukey")
print(tukey_pairwise_all)
 # contrast          estimate       SE df z.ratio p.value
 # lowland - slope  -3.64e-06 3.10e-06 NA  -1.171  0.4706
 # lowland - upland  2.82e-06 2.34e-06 NA   1.207  0.4487
 # slope - upland    6.46e-06 2.75e-06 NA   2.345  0.0499 --> marginally sig* 

#robust_model.landpos
tukey_results_landpos <- emmeans(robust_model.landpos, "landscape_position", type = "marginal")
tukey_pairwise_landpos <- pairs(tukey_results_landpos, adjust = "tukey")
print(tukey_pairwise_landpos)
# contrast          estimate       SE df z.ratio p.value
#  lowland - slope  -3.87e-06 3.11e-06 NA  -1.243  0.4278
#  lowland - upland  3.34e-06 2.24e-06 NA   1.487  0.2972
#  slope - upland    7.20e-06 2.86e-06 NA   2.520  0.0315 --> SIG* 
   
```


#Prediction error
```{r}
# MAE (model absolute error) values, interpretation is straightforward:
# 
# The model with the lower MAE provides better predictions on average
# The difference between MAE values indicates the average improvement in prediction accuracy from adding soil temperature to your model

#models 
model1 <- rlm(flux_value ~ landscape_position + air_temp, data = df_NEE)
model2 <- rlm(flux_value ~ landscape_position + VWC, data = df_NEE)
model3 <- rlm(flux_value ~ landscape_position + soil_temp_10_cm, data = df_NEE)
model4 <- rlm(flux_value ~ landscape_position +  thawdepth, data = df_NEE)
model5 <- rlm(flux_value ~ landscape_position + VWC + soil_temp_10_cm, data = df_NEE)
model6 <- rlm(flux_value ~ landscape_position + air_temp + VWC + soil_temp_10_cm + thawdepth + inundated, data = df_NEE)

# Calculate MAE for each model
MAE_model1 <- mean(abs(residuals(model1)))
MAE_model2 <- mean(abs(residuals(model2)))
MAE_model3 <- mean(abs(residuals(model3)))
MAE_model4 <- mean(abs(residuals(model4)))
MAE_model5 <- mean(abs(residuals(model5)))
MAE_model6 <- mean(abs(residuals(model6)))

# Compare
print(paste("Model 1 MAE:", MAE_model1))
print(paste("Model 2 MAE:", MAE_model2))
print(paste("Model 3 MAE:", MAE_model3))
print(paste("Model 4 MAE:", MAE_model4))
print(paste("Model 5 MAE:", MAE_model5))
print(paste("Model 6 MAE:", MAE_model6))

#Results:
# [1] "Model 1 MAE: 1.11956589579691e-05"
# [1] "Model 2 MAE: 1.10848446849771e-05"
# [1] "Model 3 MAE: 1.12094944746193e-05"
# [1] "Model 4 MAE: 1.11000440597407e-05"
# [1] "Model 5 MAE: 1.10316506716428e-05"
# [1] "Model 6 MAE: 1.07913481856258e-05" --> lowest MAE, full model 

```


#Cross-validation using RMSE
```{r}
# RMSE measures the average prediction error (lower is better)
# Each model shows 6 values because the caret package runs multiple tuning parameters by default for robust regression

library(caret)

# Create training control for 10-fold cross-validation
train_control <- trainControl(method = "cv", number = 10)

# Compare models using cross-validation
cv_full <- train(flux_value ~ landscape_position + air_temp + soil_temp_10_cm + VWC + thawdepth + inundated, 
                data = df_NEE,
                method = "rlm",
                trControl = train_control)

cv_reduced1 <- train(flux_value ~ landscape_position + air_temp, 
                   data = df_NEE,
                   method = "rlm",
                   trControl = train_control)

cv_reduced2 <- train(flux_value ~ landscape_position + soil_temp_10_cm, 
                   data = df_NEE,
                   method = "rlm",
                   trControl = train_control)

cv_reduced3 <- train(flux_value ~ landscape_position + VWC,
                   data = df_NEE,
                   method = "rlm",
                   trControl = train_control)

cv_reduced4 <- train(flux_value ~ landscape_position + thawdepth,
                   data = df_NEE,
                   method = "rlm",
                   trControl = train_control)

cv_reduced5 <- train(flux_value ~ landscape_position + VWC + soil_temp_10_cm,
                   data = df_NEE,
                   method = "rlm",
                   trControl = train_control)

# Compare RMSE
cv_full$results$RMSE
cv_reduced1$results$RMSE
cv_reduced2$results$RMSE
cv_reduced3$results$RMSE
cv_reduced4$results$RMSE 
cv_reduced5$results$RMSE #consistently the lowest RMSE, ladpos + VWC + soil temp 


```

#Correlation matrix 

####Flux v Environmental correlation matrix - soil chambers NEE 
```{r}
# Environmental relationships
# Create a correlation plot between fluxes and environmental variables

#variables of interest / used in model (except air temp), for reference 
#(complete.cases(flux_value, thawdepth, soil_temp_10_cm,landscape_position, inundated, VWC))

#can only use numeric variables, so "landscape_position and inundated can't be used 
chamber_NEE_corr_matrix <- df_NEE %>%
  select(flux_value, thawdepth, soil_temp_10_cm, VWC, air_temp) %>%
  rename(
    NEE = flux_value,
    Soil_temp_10cm = soil_temp_10_cm,
    Soil_VWC = VWC,
    Air_temp = air_temp,
    Thaw_depth = thawdepth,
  )

cor_matrix2 <- cor(chamber_NEE_corr_matrix, use = "complete.obs")

# Convert correlation matrix to long format for plotting
cor_long2 <- as.data.frame(as.table(cor_matrix2))
names(cor_long2) <- c("Var1", "Var2", "Correlation")

ggplot(cor_long2, aes(x = Var1, y = Var2, fill = Correlation)) +
  geom_tile() +
  scale_fill_gradient2(low = "red", mid = "white", high = "blue", midpoint = 0,
                        limits = c(-1, 1)) +  # Add this to set the full range to be 1 to -1
  theme_bw() +
  theme(axis.text.x = element_text(angle = 45, hjust = 1)) +
  theme(axis.text = element_text(size = 12, face = "bold"),
       plot.title = element_text(size = 14, face = "bold", hjust = 0.5)) +                 
  labs(title = "Correlation Matrix of Soil Chamber NEE Fluxes and Environmental Variables")
   



# option 2: Fewer breaks for a cleaner look, only labels corr values above 0.3 --> I like this one best 
ggplot(cor_long2, aes(x = Var1, y = Var2, fill = Correlation)) +
  geom_tile() +
  # Add correlation values only for strong correlations
  geom_text(data = subset(cor_long2, abs(Correlation) > 0.2),  # Only show stronger correlations
            aes(label = sprintf("%.2f", Correlation),
                 color = abs(Correlation) < 0.5), # Changes text color based on correlation strength
            size = 3,
            fontface = "bold") + #to make numbers in tiles bold
  scale_fill_gradient2(low = "red", 
                      mid = "white", 
                      high = "blue", 
                      midpoint = 0,
                      limits = c(-1, 1),
                      breaks = c(-1, -0.5, 0, 0.5, 1)) +
    scale_color_manual(values = c("white", "black"), guide = "none") +  # For text visibility
  theme_bw() +
  theme(axis.text.x = element_text(angle = 45, hjust = 1),
        axis.text = element_text(size = 12, face = "bold"),
        plot.title = element_text(size = 14, face = "bold", hjust = 0.5)) +                 
  labs(title = "Correlation Matrix of Soil Chamber NEE Fluxes and Environmental Variables")

 #saves the figure directly above
ggsave("C:/Users/kkent/Documents/Github Flux Network/Council_Flux_Analysis_Paper/Council Figures/Soil Chambers/soil_chamber_NEE_corr_matrix.png",
       width = 8, height = 5, dpi = 600)

```

#Partial regressions, code from Claude 
```{r}
#partial regressions looks at contribution of predictor variable while holding the other variables constant
# The partial regression plots show the relationship between each predictor and the response after removing the linear effects of all other predictors. The slope of the line in each plot corresponds to the regression coefficient for that variable in the full model.

# Multiple regression with lm
multiple_reg <- lm(flux_value ~ landscape_position + VWC + soil_temp_10_cm + thawdepth + inundated + air_temp,
                   data = df_NEE)



library(car)
avPlots(multiple_reg)  # Creates all partial regression plots
# Creating a plot for a specific variable:
#avPlot(multiple_reg, "soil_temp_10_cm")
# df_FCH4$landscape_position <- relevel(factor(df_FCH4$landscape_position), ref = "upland")
# avPlots(multiple_reg) 


#Results: air temp, thaw depth, land pos, and perhaps inundated seem to have largest slopes but all seem minimal 

library(ppcor) #Pearson corr - which assumes normality - so consider these carefully and cross-ref with non-parametric tests 
pcor.test(df_NEE$flux_value, df_NEE$soil_temp_10_cm, 
         df_NEE[, c("VWC", "thawdepth", "air_temp")])#coeff = -0.09, p=0.24

pcor.test(df_NEE$flux_value, df_NEE$VWC, 
         df_NEE[, c("soil_temp_10_cm", "thawdepth", "air_temp")])#coeff=-0.15, p = 0.06

pcor.test(df_NEE$flux_value, df_NEE$thawdepth, 
         df_NEE[, c("soil_temp_10_cm", "VWC", "air_temp")])#coeff = 0.16, p = 0.03* SIG*

pcor.test(df_NEE$flux_value, df_NEE$air_temp, 
         df_NEE[, c("soil_temp_10_cm", "VWC", "thawdepth")])#coeff = 0.24, p=0.002 *SIG*

#matches spearman corr tests 



```

#IncMSE for NEE soil chambers 
```{r}
df_NEE$landscape_position <- as.factor(df_NEE$landscape_position)
df_NEE$inundated <- as.factor(df_NEE$inundated)

library(randomForest)
rf_NEE_full <- randomForest(flux_value  ~ landscape_position + VWC + soil_temp_10_cm + thawdepth + inundated + air_temp,
                             data = df_NEE,
                             ntree = 800,
                             importance = TRUE)


# Look at variable importance
varImpPlot(rf_NEE_full) #shows thaw depth is most important, followed by VWC, then air temp - landpos is least explanatory 
```
#Partial dependence plots from RF full model 
```{r}
#Shows how each var affects NEE predictions when all other variables are held at their avg values 

library(pdp)
# Create partial dependence plot for thawdepth
pd_thawdepth <- partial(rf_NEE_full, pred.var = "thawdepth")
plot(pd_thawdepth, main = "Partial Dependence on Thaw Depth",
     ylab = "Partial Effect on NEE", xlab = "Thaw Depth")

# For soil temperature
pd_soiltemp <- partial(rf_NEE_full, pred.var = "soil_temp_10_cm")
plot(pd_soiltemp, main = "Partial Dependence on Soil Temp",
     ylab = "Partial Effect on NEE", xlab = "Soil Temp")

# For VWC
pd_VWC <- partial(rf_NEE_full, pred.var = "VWC")
plot(pd_VWC, main = "Partial Dependence on VWC",
     ylab = "Partial Effect on NEE", xlab = "VWC")

# For air temperature
pd_airtemp <- partial(rf_NEE_full, pred.var = "air_temp")
plot(pd_airtemp, main = "Partial Dependence on air temp",
     ylab = "Partial Effect on NEE", xlab = "air temp")

# For categorical variables like landscape position
#hmmm these don't work, need to try something else 

# Create partial dependence plot for landscape position (categorical)
pd_landscape <- partial(rf_NEE_full, pred.var = "landscape_position")
plot(pd_landscape, main = "Partial Dependence on Landscape Position",
     ylab = "Partial Effect on NEE", xlab = "Landscape Position")

# For a more customized plot
pd_landscape <- partial(rf_NEE_full, pred.var = "landscape_position")
barplot(pd_landscape$yhat, names.arg = pd_landscape$landscape_position,
        main = "Partial Dependence on Landscape Position",
        ylab = "Partial Effect on NEE", xlab = "Landscape Position",
        col = "skyblue")

```

#Partial dependence & Interaction plots -  they show the partial effect of the selected variables after accounting for the average effect of all other variables in RF model.
The plots help visualize the relationships that the model has learned from your actual data. --> Shows how NEE responds to different combinations of predictor variables when all other variables are held at their averages, which helps reveal the complex relationships - ("yhat" = predicted NEE, these are predicted NEE values based on the RF model)
```{r}
#have to make categorical var a factor, make sure it was factor in the model for this to work


# Interaction between landscape position (categorical) and thaw depth (continuous)
pd_interact <- partial(rf_NEE_full, pred.var = c("landscape_position", "thawdepth"))
plotPartial(pd_interact, main = "Interaction: Landscape Position and Thaw Depth")

# Interaction between landscape position (categorical) and thaw depth (continuous)
pd_interact <- partial(rf_NEE_full, pred.var = c("landscape_position", "inundated"))
plotPartial(pd_interact, main = "Interaction: Landscape Position and Inundation")


pd_continuous <- partial(rf_NEE_full, pred.var = c("landscape_position", "VWC"))
plotPartial(pd_continuous, contour = TRUE, 
            main = "Interaction: Landpos and VWC")



# Or for a continuous-continuous interaction (VWC and soil temperature)
pd_continuous <- partial(rf_NEE_full, pred.var = c("VWC", "soil_temp_10_cm"))
plotPartial(pd_continuous, contour = TRUE, 
            main = "Interaction: VWC and Soil Temperature")


pd_continuous <- partial(rf_NEE_full, pred.var = c("VWC", "thawdepth"))
plotPartial(pd_continuous, contour = TRUE, 
            main = "Interaction: VWC and Thaw Depth")

pd_continuous <- partial(rf_NEE_full, pred.var = c("air_temp", "thawdepth"))
plotPartial(pd_continuous, contour = TRUE, 
            main = "Interaction: Air temp and Thaw Depth")

pd_continuous <- partial(rf_NEE_full, pred.var = c("thawdepth", "soil_temp_10_cm"))
plotPartial(pd_continuous, contour = TRUE, 
            main = "Interaction: Thaw Depth and Soil Temperature")

```
#NEE response to multiple variables based on actual observations
```{r}
library(ggplot2)

# Basic scatterplot with trend lines for each landscape position
ggplot(df_NEE, aes(x = thawdepth, y = flux_value, color = landscape_position)) +
  geom_point(alpha = 0.6) +
  geom_smooth(method = "loess", se = TRUE) +
  labs(title = "Observed NEE by Thaw Depth and Landscape Position",
       x = "Thaw Depth (cm)",
       y = "NEE (flux_value)",
       color = "Landscape Position") +
  theme_bw()

# Faceted by landscape position (similar to interaction plot)
ggplot(df_NEE, aes(x = thawdepth, y = flux_value)) +
  geom_point(alpha = 0.6) +
  geom_smooth(method = "loess", se = TRUE) +
  facet_wrap(~landscape_position) +
  labs(title = "Observed NEE by Thaw Depth and Landscape Position",
       x = "Thaw Depth (cm)",
       y = "NEE (flux_value)") +
  theme_bw()


# Scatter plot with color representing NEE
ggplot(df_NEE, aes(x = VWC, y = soil_temp_10_cm, color = flux_value)) +
  geom_point(size = 3, alpha = 0.7) +
  scale_color_gradient2(midpoint = median(df_NEE$flux_value),
                       low = "blue", mid = "green", high = "yellow") +
  labs(title = "Observed NEE by VWC and Soil Temperature",
       x = "VWC (%)",
       y = "Soil Temperature (10 cm)",
       color = "NEE") +
  theme_bw()

# Or as a 2D density contour plot with NEE as fill color
library(fields) # For interpolation

# Create bins for VWC and soil_temp to aggregate flux values
df_NEE$VWC_bin <- cut(df_NEE$VWC, breaks = 10)
df_NEE$temp_bin <- cut(df_NEE$soil_temp_10_cm, breaks = 10)

# Aggregate mean flux values by the bins
agg_data <- aggregate(flux_value ~ VWC_bin + temp_bin, data = df_NEE, FUN = mean)

# Get midpoints of bins
agg_data$VWC_mid <- as.numeric(gsub(".*,(.*)\\]", "\\1", agg_data$VWC_bin))
agg_data$temp_mid <- as.numeric(gsub(".*,(.*)\\]", "\\1", agg_data$temp_bin))

# Plot the aggregated data
ggplot(agg_data, aes(x = VWC_mid, y = temp_mid, fill = flux_value)) +
  geom_tile() +
  scale_fill_gradient2(midpoint = 0,
                     low = "blue", mid = "green", high = "yellow") +
  labs(title = "Observed NEE by VWC and Soil Temperature",
       x = "VWC (%)",
       y = "Soil Temperature (10 cm)",
       fill = "NEE") +
  theme_bw()
```
#Variable x landpos 

```{r}
#thawdepth x landpos 

# Basic scatterplot with trend lines for each landscape position
ggplot(df_NEE, aes(x = thawdepth, y = flux_value, color = landscape_position)) +
  geom_point(alpha = 0.6) +
  geom_smooth(method = "loess", se = TRUE) +
  labs(title = "Observed NEE by Thaw Depth and Landscape Position",
       x = "Thaw Depth (cm)",
       y = "NEE (flux_value)",
       color = "Landscape Position") +
  theme_bw()

# Faceted by landscape position (similar to interaction plot)
ggplot(df_NEE, aes(x = thawdepth, y = flux_value)) +
  geom_point(alpha = 0.6) +
  geom_smooth(method = "loess", se = TRUE) +
  facet_wrap(~landscape_position) +
  labs(title = "Observed NEE by Thaw Depth and Landscape Position",
       x = "Thaw Depth (cm)",
       y = "NEE (flux_value)") +
  theme_bw()


#VWC x land pos 
# Basic scatterplot with trend lines for each landscape position
ggplot(df_NEE, aes(x = VWC, y = flux_value, color = landscape_position)) +
  geom_point(alpha = 0.6) +
  geom_smooth(method = "loess", se = TRUE) +
  labs(title = "Observed NEE by VWC and Landscape Position",
       x = "VWC %",
       y = "NEE (flux_value)",
       color = "Landscape Position") +
  theme_bw()

# Faceted by landscape position (similar to your interaction plot)
ggplot(df_NEE, aes(x = VWC, y = flux_value)) +
  geom_point(alpha = 0.6) +
  geom_smooth(method = "loess", se = TRUE) +
  facet_wrap(~landscape_position) +
  labs(title = "Observed NEE by VWC and Landscape Position",
       x = "VWC%",
       y = "NEE (flux_value)") +
  theme_bw()


# air temp x landpos 
# Basic scatterplot with trend lines for each landscape position
ggplot(df_NEE, aes(x = air_temp, y = flux_value, color = landscape_position)) +
  geom_point(alpha = 0.6) +
  geom_smooth(method = "loess", se = TRUE) +
  labs(title = "Observed NEE by Air T and Landscape Position",
       x = "Air T (C)",
       y = "NEE (flux_value)",
       color = "Landscape Position") +
  theme_bw()

# Faceted by landscape position (similar to your interaction plot)
ggplot(df_NEE, aes(x = air_temp, y = flux_value)) +
  geom_point(alpha = 0.6) +
  geom_smooth(method = "loess", se = TRUE) +
  facet_wrap(~landscape_position) +
  labs(title = "Observed NEE by Air T and Landscape Position",
       x = "Air T (C)",
       y = "NEE (flux_value)") +
  theme_bw()



# soil temp x landpos 
# Basic scatterplot with trend lines for each landscape position
ggplot(df_NEE, aes(x = soil_temp_10_cm, y = flux_value, color = landscape_position)) +
  geom_point(alpha = 0.6) +
  geom_smooth(method = "loess", se = TRUE) +
  labs(title = "Observed NEE by Soil Temp and Landscape Position",
       x = "Soil T (C)",
       y = "NEE (flux_value)",
       color = "Landscape Position") +
  theme_bw()

# Faceted by landscape position (similar to your interaction plot)
ggplot(df_NEE, aes(x = soil_temp_10_cm, y = flux_value)) +
  geom_point(alpha = 0.6) +
  geom_smooth(method = "loess", se = TRUE) +
  facet_wrap(~landscape_position) +
  labs(title = "Observed NEE by Soil Temp and Landscape Position",
       x = "Soil Temp (C)",
       y = "NEE (flux_value)") +
  theme_bw()


```

#Variable x inundated 
```{r}
#thawdepth x inundated

ggplot(df_NEE, aes(x = thawdepth, y = flux_value, color = inundated)) +
  geom_point(alpha = 0.6) +
  geom_smooth(method = "loess", se = TRUE) +
  labs(title = "Observed NEE by Thaw Depth and Inundation",
       x = "Thaw Depth (cm)",
       y = "NEE (flux_value)",
       color = "inundated") +
  theme_bw()

# Faceted by inundated (similar to interaction plot)
ggplot(df_NEE, aes(x = thawdepth, y = flux_value)) +
  geom_point(alpha = 0.6) +
  geom_smooth(method = "loess", se = TRUE) +
  facet_wrap(~inundated) +
  labs(title = "Observed NEE by Thaw Depth and Inundation",
       x = "Thaw Depth (cm)",
       y = "NEE (flux_value)") +
  theme_bw()


#VWC x inundated

ggplot(df_NEE, aes(x = VWC, y = flux_value, color = inundated)) +
  geom_point(alpha = 0.6) +
  geom_smooth(method = "loess", se = TRUE) +
  labs(title = "Observed NEE by VWC and inundated",
       x = "VWC %",
       y = "NEE (flux_value)",
       color = "inundated") +
  theme_bw()


ggplot(df_NEE, aes(x = VWC, y = flux_value)) +
  geom_point(alpha = 0.6) +
  geom_smooth(method = "loess", se = TRUE) +
  facet_wrap(~inundated) +
  labs(title = "Observed NEE by VWC and inundated",
       x = "VWC%",
       y = "NEE (flux_value)") +
  theme_bw()


# air temp x inundated 

ggplot(df_NEE, aes(x = air_temp, y = flux_value, color = inundated)) +
  geom_point(alpha = 0.6) +
  geom_smooth(method = "loess", se = TRUE) +
  labs(title = "Observed NEE by Air T and inundated",
       x = "Air T (C)",
       y = "NEE (flux_value)",
       color = "inundated") +
  theme_bw()


ggplot(df_NEE, aes(x = air_temp, y = flux_value)) +
  geom_point(alpha = 0.6) +
  geom_smooth(method = "loess", se = TRUE) +
  facet_wrap(~inundated) +
  labs(title = "Observed NEE by Air T and inundated",
       x = "Air T (C)",
       y = "NEE (flux_value)") +
  theme_bw()



# soil temp x inundated 

ggplot(df_NEE, aes(x = soil_temp_10_cm, y = flux_value, color = inundated)) +
  geom_point(alpha = 0.6) +
  geom_smooth(method = "loess", se = TRUE) +
  labs(title = "Observed NEE by Soil Temp and inundated",
       x = "Soil T (C)",
       y = "NEE (flux_value)",
       color = "inundated") +
  theme_bw()


ggplot(df_NEE, aes(x = soil_temp_10_cm, y = flux_value)) +
  geom_point(alpha = 0.6) +
  geom_smooth(method = "loess", se = TRUE) +
  facet_wrap(~inundated) +
  labs(title = "Observed NEE by Soil Temp and inundated",
       x = "Soil Temp (C)",
       y = "NEE (flux_value)") +
  theme_bw()




```